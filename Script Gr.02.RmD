---
title: "Script Gr 02 (NEU!)"
output: html_document
---

Installing different packages needed for the following code and loading the library
```{r}
install.packages("ggplot2")
library(ggplot2)
install.packages("gridExtra")
library(gridExtra)
install.packages("reshape2")
library(reshape2)
install.packages("data.table")
library(data.table)
install.packages("cluster")
library(cluster)
install.packages("rstudioapi")
library(rstudioapi)
install.packages("pheatmap")
library(pheatmap)
install.packages("caret")
library(caret)
install.packages("tidyverse")
library(tidyverse)
install.packages("dendextend")
library(dendextend)
install.packages("factoextra")
library(factoextra)
install.packages("devtools")
library(devtools)
install.packages("ggbiplot")
library(ggbiplot)
```

Setting the sys-path
```{r}
root.dir = dirname(rstudioapi::getSourceEditorContext()$path)
```


Part 1: Data Cleanup

First we are loading our data. (with paste0 you can concatenate strings; here some paths this makes your code very flexible). 
The mutation data is different from the other matrixes, so we define a new matrix only containing the mtation data
```{r}
data = readRDS(paste0(root.dir,"/DepMap19Q1_allData.RDS"))
mut <- data$mutation 
```

Additionally to the mutation matrix we want another matrix only containing the data which is not the mutation matrix.
#define an operator that will only pick the data that is NOT defined in the list; so the data that needs to be excluded so in our case: DNase, Methylation and RNA data should be excluded; so it will extract nothing, extract only non-mutation data, rename the data with the original names 
```{r}
'%!in%' <- function(x,y)!('%in%'(x,y)) 
dt_new <- lapply(which(names(data) %!in% "mutation"), function(a) data[[a]]) 
names(dt_new) <- names(data)[which(names(data) %!in% "mutation")] 
```

#define the samples so we can extract only our cancer type of interest
```{r}
sample_case = c("Skin Cancer") 
``` 

We look at the annotation matrix an search only for the Primary diseases which match the previous defined sample case (Skin cancer) 
```{r}
samples = data$annotation$DepMap_ID[which(data$annotation$Primary.Disease == sample_case)]
```

extracting only the celllines with skin cancer as the primary disease from our matrices (dt_new) and save the new matrices in a new large list (processed_data)
#pick the data for your sample, #pick one file at each iteration #make a datacleanup
```{r}
processed_data <- lapply(1:length(dt_new), function(a) {  
  dat_picker <- dt_new[[a]]  
  output <- dat_picker[,which(colnames(dat_picker) %in% samples)]
  output <- output[complete.cases(output),]
  output <- output[order(rownames(output)),]
  return(output)
})
names(processed_data) <- names(dt_new)
```

Now we extract our cellines from the mutation data
#extract the mutation data (take care; this is a list of lists; therefore special treatment needed)
```{r}
ids = which(names(mut) %in% samples) 
allDepMap_mutation_SkinCancer = lapply(ids, function(a) {
  mut[[a]]})
```

Renaming rows of the mutation data after the celllines
# putting the names of the matrixes in the allDep_mutation
```{r}
names(allDepMap_mutation_SkinCancer) <- samples
```

Losing the mutations which are not deleterious meaning not interesting to us
# losing the mutations which are not deleterious
```{r}
allDepMap_mutation_SkinCancer = lapply(1:34, function(a) {allDepMap_mutation_SkinCancer[[a]][which(allDepMap_mutation_SkinCancer[[a]][,"isDeleterious"]== TRUE), ]})
```

!!!!!!!! mittlerer code funktioniert nicht!!!!!!!!
# losing all the genes which are not in every data frame 
```{r}
 a <- unique(c(rownames(processed_data[[1]]),rownames(processed_data[[2]]),rownames(processed_data[[3]]),rownames(processed_data[[4]])))


b <-sapply(seq_along(a), function(x){
  if(a[x] %in% rownames(processed_data$expression) & a[x] %in% rownames(processed_data$copynumber) & a[x] %in% rownames(processed_data$kd.ceres) & a[x] %in% rownames(processed_data$kd.prob))
  {return(a[x])} else {
    next
  }
})


b <- as.vector(b)

b <- complete.cases(b)
```

Part 2: Data vizualisation

Creating new data for plotting out of our data of interest -> 
#take care to take not all the processed data becasue we will not need annotation, bind the data togehter that we have samples and values as columns, add the genes; probably this might be useful in a later stage, add a labelling column rename the colums, rename the data
```{r}
finalPlottingData <- lapply(1:(length(processed_data)-1), function(a) {
  dtPicker <- processed_data[[a]]
  out <- melt(dtPicker)  
  out$Gene <- rep(rownames(dtPicker), ncol(dtPicker)) 
  out$Case <- names(processed_data)[1:(length(processed_data)-1)][a] 
  colnames(out) <- c("Sample", "Value", "Gene", "Case") 
  return(out)
})
names(finalPlottingData) <- names(processed_data)[1:(length(processed_data)-1)]  
lapply(finalPlottingData, head)
```

Plotting the data of the expression matrix out of the finalPlottingData. Creating coloured boxplots for each cellline. We are mainly interested in the boxplots itself so we reconstuct the outliers -> reduce them in size
#coloured boxplots, reconstruct the outliers a bit (so reduce them in size; because we are interested in the boxplots and not the outliers), #format the size of the theme nicely, #define the legend position (here no leghend will be needed), #define the legend direction if one is there, #make the title of the plot into the middle, #define the orientation of the text on the x-axis, #no title of the legend should be plotted, #no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming, #define the orientation of the text of the y-axis
```{r}
ggplot(data = finalPlottingData$expression, aes(x=Sample, y=Value)) +
  geom_boxplot(aes(fill = Sample), outlier.size = 0.1, outlier.alpha = 0.2) + 
  theme_bw(base_size = 7) + 
  theme(legend.position= "none", 
        legend.direction="horizontal", 
        plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        legend.title= element_blank(), 
        axis.title.x = element_blank(), 
        strip.text.y = element_text(angle = 90)) 
```

creating a heatmap with the kd.ceres values -> not the whole matrix just the first ten genes and all the celllines, 
#take care blue means really, really significant p-value!
```{r}
pheatmap(as.matrix(processed_data$kd.ceres[1:10, 1:34]), clustering_method = "ward.D2",border_color = "white", fontsize = 10, 
         main = paste0("kdCERES for potential 2nd site targets"),
         show_rownames = F, show_colnames = T,
         cutree_rows = 4,
         cutree_cols = 2, 
         fontsize_row=10) 
```

Creating a hierachical cluster with the celllines of the kd.ceres
```{r}
cor.mat = cor(processed_data$kd.ceres[1:50,], method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
plot(cor.hc, las = 2, cex.lab = 0.7)
```

histogram, 
#pick one gene, #pick one of the 34 mutation lists, #look how often an entry is is in the mutation list, #sum it up to get the total count for each gene, #rename it nicely, #make a nice dataframe, #sort the data frame
```{r}
singleGenes <- as.vector(unique(as.data.frame(rbindlist(lapply(seq_along(allDepMap_mutation_SkinCancer), function(a) {out <- as.data.frame(as.vector(unique(allDepMap_mutation_SkinCancer[[a]]$Hugo_Symbol)))}))))[,1])

geneCounts <- sapply(seq_along(singleGenes), function(a) {
  genePicker <- singleGenes[a] 
  print(paste0("I am doing: ", a))
  sumGene <- lapply(seq_along(allDepMap_mutation_SkinCancer), function(b) {
    mutPicker <- allDepMap_mutation_SkinCancer[[b]] 
    out <- as.data.frame(length(which(mutPicker$Hugo_Symbol == genePicker))) 
    return(out)
  })
  geneCount <- colSums(as.data.frame(rbindlist(sumGene))) 
  return(geneCount)
})
names(geneCounts) <- singleGenes 
geneCounts <- as.data.frame(geneCounts) 
colnames(geneCounts) <- c("Value")
sortedGenCounts <- geneCounts[order(-geneCounts$Value), , drop = FALSE] 
head(sortedGenCounts)
```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Plotting only the top 50 genes, 
#format the size of the theme nicely, #define the legend position (here no leghend will be needed), #define the legend direction if one is there, make the title of the plot into the middle, #define the orientation of the text on the x-axis, #no title of the legend should be plotted, #no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming, #define the orientation of the text of the y-axis
```{r}
plotData <- sortedGenCounts[1:40, ,drop = FALSE]

plotData$Gene <- rownames(plotData)

plotData$Gene <- factor(plotData$Gene, levels = plotData$Value)

ggplot(data = plotData) +
  (geom_bar(mapping = aes(x = Gene, y = Value), stat = "identity")) +
  theme_bw(base_size = 7) + 
  theme(legend.position= "none", 
        legend.direction="horizontal", 
        plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        legend.title= element_blank(), 
        axis.title.x = element_blank(), 
        strip.text.y = element_text(angle = 90)) 
```


Part 3: Dimensionality reduction (PCA and kmeans)

Extract the data for the top 40 genes and creating a new data set with the different matrices only containing those 40 genes
#pick the data for your sample, #pick one file at each iteration 
```{r}
topDriverGenes <- rownames(plotData)

dataTopDriverGenes <- lapply(1:length(processed_data), function(a) { 
  dat_picker <- processed_data[[a]] 
  output <- dat_picker[which(rownames(dat_picker) %in% topDriverGenes),]
  return(output)
})
names(dataTopDriverGenes) <- names(dt_new)
lapply(dataTopDriverGenes, head)
```

Extract data for expression and ceres
```{r}
driverexpression <- dataTopDriverGenes$expression
driverkd.ceres <- dataTopDriverGenes$kd.ceres
```

kmeans
```{r}
lapply(1:34, function(v){ "ABAT" %in% allDepMap_mutation_SkinCancer[[5]][,"Hugo_Symbol"]})



km = kmeans(x =t(driverexpression), centers = 6, nstart = 30)
wss = sapply(1:11, function(k) {
  kmeans(x = t(driverexpression), centers = k)$tot.withinss
})
plot(1:11, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares")


D = dist(t(driverexpression))
km = kmeans(x = t(driverexpression), centers = 8, nstart = 100)

fviz_cluster(km, data = t(driverexpression))

D = dist(t(driverexpression))
plot(silhouette(km$cluster, D))
mean(silhouette(km$cluster, D))
a = silhouette(km$cluster, D)
```

# function to compute average silhouette for k clusters
```{r}
avg_sil <- function(k) {
  km.res <- kmeans(t(driverexpression), centers = k, nstart = 25)
  ss <- silhouette(km.res$cluster, dist(t(driverexpression)))
  mean(ss[, 3])
}
```

# Compute and plot wss for k = 2 to k = 15
```{r}
k.values <- 2:15
```

# extract average silhouette for 2-15 clusters
```{r}
avg_sil_values <- map_dbl(k.values, avg_sil)

plot(k.values, avg_sil_values,
     type = "b", pch = 19, frame = FALSE, 
     xlab = "Number of clusters K",
     ylab = "Average Silhouettes")




fviz_nbclust(t(driverexpression), kmeans, method = "silhouette")

km2 <- kmeans(t(driverexpression), centers = 2, nstart = 25)
km3 <- kmeans(t(driverexpression), centers = 6, nstart = 25)
km4 <- kmeans(t(driverexpression), centers = 4, nstart = 25)
km5 <- kmeans(t(driverexpression), centers = 9, nstart = 25)
```

Plots to compare the different number of clusters for k-means
# plots to compare
```{r}
p1 <- fviz_cluster(km2, geom = "text", labelsize = 8, data = t(driverexpression)) + ggtitle("k = 2")
p2 <- fviz_cluster(km3, geom = "text", labelsize = 8, data = t(driverexpression)) + ggtitle("k = 6")
p3 <- fviz_cluster(km4, geom = "text", labelsize = 8, data = t(driverexpression)) + ggtitle("k = 4")
p4 <- fviz_cluster(km5, geom = "text", labelsize = 8, data = t(driverexpression)) + ggtitle("k = 9")


grid.arrange(p1, p2, p3, p4, nrow = 2)

rm(km,km2,km3,km4,km5,p1,p2,p3,p4)
```

!!!!!!!!!!!!!!!!!!!!!!!!
PCA, Anzeigen von labels (Zelllinien)
```{r}
pca = prcomp(t(driverexpression), center = F, scale. = F)
summary(pca)
autoplot(prcomp(t(driverexpression)), data = t(driverexpression), colour = 'blue')
autoplot(prcomp(t(driverexpression)), data = t(driverexpression), colour = 'blue', label = TRUE, label.size = 2)
str(pca)
plot(pca, type = "l")
```


Part 4 statistical test
#only use the TOP 10 driver genes, #pick one driver gene, #the kdCERES matrix is of interest take its' rownames as refrence, #pick a potetnial 2nd site target, #pick the driver mut data, #pick the 2nd site data, #make a spearman correlation, #return the p-values, #rename all, #get a nice dataframe, #rename the list of lists, #look at the nice data
```{r}
driverGenes <- topDriverGenes[1:10] 
ttestgenes <- rownames(driverkd.ceres)

potSecondSites <- lapply(seq_along(driverGenes), function(a) {
  genePicker <- driverGenes[a] 
  print(paste0("I am doing driver mut: ", a))
  output <- sapply(seq_along(rownames(processed_data$kd.ceres)), function(b) { 
    secondSitePicker <- rownames(processed_data$kd.ceres)[b] 
    if (secondSitePicker != genePicker) {
      drMUT <- processed_data$kd.ceres[which(rownames(processed_data$kd.ceres) == genePicker),] 
      sndMUT <- as.vector(processed_data$kd.ceres[which(rownames(processed_data$kd.ceres) == secondSitePicker),]) 
      cor.val <- cor.test(unlist(drMUT, use.names=FALSE) , unlist(sndMUT, use.names=FALSE), method = "spearman") 
      return(cor.val$p.value) 
    } else {
      return(1)
    }
  })
  names(output) <- rownames(processed_data$kd.ceres) 
  output <- as.data.frame(output) 
  return(output)
})
names(potSecondSites) <- driverGenes 
lapply(potSecondSites, head) 
```

Ordering the data according to their p-values and creating a new data set with the potentional Target genes (Top ten genes with the lowest so most important p-value)
```{r}
potSecondSites <- lapply(potSecondSites, function(a){
  a <- as.data.frame(cbind(a$output, rownames(a)))
  a <- a[order(a[1]), ]
})
```

!!!!!!!!!!!!!!!!!!!!!!!!!
# selecting the 20 Genes out of every DriverGene List with the lowest p score, #format the size of the theme nicely, #define the legend position (here no leghend will be needed), #define the legend direction if one is there, #make the title of the plot into the middle, #define the orientation of the text on the x-axis, #no title of the legend should be plotted, #no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming, #define the orientation of the text of the y-axis
```{r}
potSecondSitestop20 <- lapply(seq_along(potSecondSites), function (a){
  output <- potSecondSites[[a]][1:20,]
  return(output)
})
names(potSecondSitestop20) <- driverGenes


potSecondSitestop20plot <- lapply(seq_along(potSecondSitestop20), function(a){
  output <- ggplot(data = potSecondSitestop20[[a]]) +
    (geom_bar(mapping = aes(x = V2, y = V1), stat = "identity")) +
    theme_bw(base_size = 7) + 
    theme(legend.position= "none", 
          legend.direction="horizontal", 
          plot.title = element_text(hjust = 0.5), 
          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
          legend.title= element_blank(), 
          axis.title.x = element_blank(), 
          strip.text.y = element_text(angle = 90))
  return(output)
})
```


Part 5: linear Regression
